\documentclass{article}
\usepackage{cite}
\usepackage[colorlinks=true,linkcolor=black,urlcolor=black,citecolor=black]%
{hyperref}
\renewcommand{\t}{\texttt}

\title{He-Man: A domain-specific language for lightweight concurrency}
%\subtitle{I said hey, what's goin' on}
\author{Carlo Angiuli \and Michael Sullivan}
\date{December 12, 2011}

\begin{document}
\maketitle

\section{Introduction}

Modern network applications need to support many simultaneous clients---this is
known as the C10K (``10,000 client'') problem\cite{Kegel}. Modern servers have
enough memory and network resources to support this many 

To maintain these simultaneous connections, an application must maintain each
client's state independently;

while 
block each one

The simplest way to do this is to spawn a thread for each client, but this
approach does not scale as the number of clients grows. 

A lightweight approach is to use kernel mechanisms for multiplexed, non-blocking
I/O, such as \t{select}, \t{poll}, \t{epoll}, or \t{kquery}; unfortunately, to
maintain separate state for each client, application programmers must manually
structure their code as state machines, which is tedious and error-prone.
Unsurprisingly, there exist many thin C/C++ wrappers for these facilities, but
none avoid major code refactoring.

To maintain the illusion of threads (in particular, client-specific state),
languages like Erlang and Haskell provide lightweight threading via user-space
schedulers and non-blocking IO. While this affords better performance, the full
generality of this approach still imposes unnecessary overhead on networking
applications which don't require preemptable, independently scheduled threads
\cite{Vinoski}.

Because 

Hence, we intend to produce an embedded domain-specific language in Haskell to
describe concurrent network applications. This language will provide composable,
high-level network operations, in which programmers may express their
application logic naturally, as if using threads. 

However, this high-level description will be automatically synthesized into a
state machine representation usable in a C loop invoking \t{epoll}, using no
threads whatsoever. We will additionally output a graphical representation of
this underlying state machine.

Generate C source code which itself implements the network application, linkable
with native C code.

simple runtime

\section{Related work}

The Nginx\cite{Nginx} and Lighttpd\cite{Lighttpd} HTTP servers use an
event-based architectures, unlike Apache's threads\cite{Apache}, with the
specific goal of addressing the C10k problem,

Haskell event loop stuff: \cite{LiZdancewic}

Haskell has epoll support and lightweight threads

Erlang


\section{Front-end}

\section{Back-end}

\section{Performance}

Each thread takes up XXX memory (see Memory.hs)

HTTP server performance is XXX

\section{Future work}

\section{Conclusions}

\bibliography{citations}{}
\bibliographystyle{plain}

\end{document}
