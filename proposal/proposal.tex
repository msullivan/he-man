\documentclass{article}
\usepackage{cite}
\renewcommand{\t}{\texttt}

\title{15-744 Project Proposal}
\author{Carlo Angiuli \and Michael Sullivan}
\date{September 28, 2011}

\begin{document}
\maketitle

% Needs to include:
%  - problem statement
%  - state-of-the-art
%  - work plan / milestones

\section{Motivation}

Ideally, network applications should be able to support many simultaneous
clients---this is known as the C10K (``10,000 client'') problem\cite{c10k}.
Maintaining connections simultaneously requires an application to track each
client's state independently. A straightforward way to do this is to spawn a
thread for each client. However, this approach does not scale as the number of
clients grows. 

A lightweight approach is to use kernel-supported nonblocking IO with
multiplexing such as \t{select}, \t{poll}, \t{epoll}, or \t{kquery}. This
require the application programmer to structure the code as a state machine,
which is tedious and error-prone. Unsurprisingly, there exist many thin C/C++
wrappers for these facilities, but these still require structuring the
application code as a state machine.

To maintain the illusion of (?) client-specific state (?) languages like Erlang
and Haskell provide lightweight thread mechanisms built on a user-space
scheduler with nonblocking IO. While this solution is significantly better, the
full generality of this approach still imposes unnecessary overhead on
networking applications which don't require preemptable, independently scheduled
threads.
(cite Erlang)

and provide no assurance that the program ...

\section{Proposal}

Hence, we intend to produce an embedded domain-specific language in Haskell for
describing multi-client network applications. 

This language will provide composable, high-level abstractions for network
operations which permits programmers to write server logic naturally, as if the
application were threaded, while automatically synthesizing a state machine
representation for use with a nonblocking main loop (as necessary for
\t{epoll}).

We will additionally be able to output a graphical representation of the
underlying state machine logic.

The back-end of this system could be implemented via several different options
which we are still evaluating. One option is to directly interface with the
\t{epoll} hooks in the Haskell runtime system, bypassing the native lightweight
threading mechanism. Another would be to generate C source code which itself
implements the network application.

optionally linkable with native C code.

easily extensible with more protocol definitions

embedded in Haskell: natively allows functional metaprogramming,
leverages native type system

\section{Milestones}

We will first collect a representative sample of network applications and
examine the range of high-level primitives required to support them. We will
then decide on a specific back-end for our language, and begin implementing it.
To evaluate the utility of this language, we will build a number of
representative servers in our language (e.g., echo server, simple HTTP server)
and compare them to traditional implementations with regard to code simplicity
and performance.

\bibliography{citations}{}
\bibliographystyle{plain}

\end{document}
